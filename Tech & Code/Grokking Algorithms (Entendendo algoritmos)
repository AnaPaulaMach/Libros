Opinion:

*********************************************************************************************************************************************************************************************************************************

1 : Introduccion a los Algoritmos
Busqueda Binaria: 
  Entrada: Lista ordenada de elementos
  Explicacion: Por ejemplo en una lista de numeros es ir diciendo si es muy bajo o muy alto el numero en relacion con al que se compara. O(Log n)

La notacion Big O informa que tan rapido es un algoritmo, no muestra el tiempo en segundos sino en cantidad de operaciones.
O(n), n seria el numero de operaciones (cantidad de numeros o logaritmos). Es big O pq es como una O que abraza la cantidad de operaciones.
Esta establece el tiempo de ejecuscion para el peor caso
O(log n): Tiempo logaritmico ; O(n): Tiempo linear ; Mas en pagina 34.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2 : Ordenacion por Seleccion
Arreglos: Los items tienen que estar todos en espacios continuos de memoria y si faltan espacios se tienen que mover toodos.
    Ventajas: Los items tienen una direccion 
    Lectura O(1) {tiempo constante} ; Insercion O(n) {tiempo lineal}

Listas: Los item pueden esta en cualquier lugar de la memoria.
    Ventajas: Se pueden aniadir items de forma ilimitada ; Mejor si quiero insertar/elimianr un elemento entre elementos;
    Desventajas: Para llegar a un item hay que pasar por todos los anteriores ; 
    Insercion O(1) {tiempo constante} ; Lectura O(n) {tiempo lineal}

Ordenamiento por seleccion:
Es basicamente ver la lista/array entera y elegir el mas grande y sacrlo. Despues con los que quedan lo mismo.
Es O(n*n) a pesar de que el tamanio de la lista vaya disminuyendo.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3 : Recursion
Caso Base: Cuando la recursion debe parar, a diferencia del Caso Recursivo que es el que vuelve a realizarse

Pila: Push (agregar elemento) ; Pop (remover elemento) ; 

Pila de Llamada (Call Stack): Cada vez que una funcion convoca a otra (funcion2), apila funcion2 sobre funcion y una vez que funcion2 termina (que tambien puede tener funciones adentro) vuelve a funcion sin nada apilado
y puede volver a apilar otra (Pag. 63). La funcion en la cima es donde se encuentra actualmente

Leigh Caldwel: "Los loops pueden mejorar el desempenio de su programa. La recursion mejora el desempenio de su programador. Elija la que fuese mas importante para su situacion"


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4 : Quicksort (Metodo de Ordenacion)
Dividir para conquistar
  - Primero se debe descubrir el caso base (el mas simple posible)
  - Despues dividir el problema para que sea el caso base

Quicksort
  -

Notacion Big O
   A pesar que no consideramos las constantes a veces estas pueden hacer la diferencia. Por eso por mas que en la notacion se hable del peor caso tambien podemos hablar de casos promedios que serian menores a ese

Caso Medio vs Peor Caso
  - El desempenio de quicksort depende del pivot elegido
  - Lo mejor es elegir un caso random como pivot, porque si se elige siempre el primero no se garantiza que el tiempo sea el menor (va el otro tampoco pero el libro dice que es lo mejor)


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5 : Tablas Hash - Diccionarios
Es una funcion en la cual se inserta un string y despues de eso la funcion retorna un numero
  - Debe ser consistente (siempre devolver lo mismo)
  - Para cada string devuelve distintas posiciones de indice   
  - Se usan para mapear item con relacion a otro, buscar algo.
  - En pythonL dict() o {}
  - Ejercucion O(1)
  - Son tan rapidas como los arrays para la busqueda y como las listas para la insercion y remover
  - Factor de carga: mide cuantos espacios continuan vacios en la tabla hash. Tiene que ser menor a 1. Se recomienda redimencionar cuando el factor de carga sea mayor a 0.7


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6 : Busqueda en Anchura (BFS)
Permite encontrar el menor camino entre dos objetos

Grafo
  - Es un conjunto de conexiones compuesto por vertices y aristas.

Busqueda en lo ancho
2 preguntas
  - Existe un camino entre A y B? Una vez que ya se sabe esta respuesta se pasa a la siguiente
  - Cual es el camino minimo entre A y B?

Fila  
  - Estructura de datos que funciona como una fila en la vida real
  - Operaciones: Enqueue y Dequeue

Implementacion del Grafo
  - Usando una tabla hash con vectores
  - Si el grafo no es direccionado o direccionado hace la diferencia
  - Siempre que se busque verificar algo intene no verificarlo dos veces porque esto puede causar un loop infinito

Arbol
  -Tipo especial de grafo en el que una arista nunca apunta de vuelta


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7 : Algoritmo de Dijkstra
  1. Se busca el vertice mas barato (de los que alcance actualmente)
  2. Verificar si existe un camino mas barato para los vecinos
  3. Repetir hasta haberlo hecho para cada vertice del grafo
  4. Calcule el camino final

Grafo Ponderado: el que tiene pesos -> Algoritmo Dijktra (Busca el de menor peso)
Grafo No Ponderado: no tiene pesos -> Busqueda en Anchura (Busca el camino mas corto)

  - No se puede usar el Algoritmo de Dijkstra con valores negativos -> Algoritmo de Bellman-Ford


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
8 : Algoritmos Gulosos (greedy)
  - Optimizan localmente con la esperanza de encontrar la solucion global mas optima
  - Son falices de escribir y tienen tiempo de ejecucion bajo por lo tanto son buenos algoritmos de aproximacion.
Para um algoritmo ser considerado guloso (greedy), ele deve seguir uma regra de ouro: em cada etapa,
ele faz a escolha que parece ser a melhor naquele momento exato, sem nunca reconsiderar essa decis√£o ou olhar para o problema de forma global.

Caracteristicas de Problemas NP-Completos
  - No tienen una solucion rapida
  - En caso de tener uno lo mejor es usar un Algoritmo de Aproximacion

No son faciles de identificar pero algunos indicativos pueden ser
  - El algoritmo es rapido para pocos items pero lento para muchos
  - Dice "Todas las combinaciones de X"
  - Hay que calcular "Cada version posible de X" porque no se puede dividir en subproblemas menores
  - Envuelve una secuencia o un conjunto

Algoritmo de Aproximacion
  - No me quedo claro pero supongo que es elegir primero el que mas se adapte a lo que yo quiero (mas cosas, menor precio) y a partir de eso seguir eligiendo










